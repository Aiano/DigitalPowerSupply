/*
 * gt9xx.c
 *
 *  Created on: Mar 20, 2024
 *      Author: ZuoenDeng
 */
#include "gt911.h"
//#include <stdio.h>

#include "usbd_cdc_if.h"
#include <stdio.h>
#include <string.h>

/*创建触摸结构体*/
Touch_Struct	User_Touch;

// GT911驱动配置，默认使用第一份配置文件，如果屏幕异常，可尝试使用第二份
#if  0
//uint8_t CTP_CFG_GT911[] =  { // 总共186个R/W寄存器
//	0x41,				//0x8047		版本号
//	0x40,0x01,	//0x8048/8049	X坐标输出最大值320
//	0xF0,0x00,	//0x804a/804b	Y坐标输出最大值240
//	0x05,				//0x804c	输出触点个数上限
//	0x4D,				//0x804d	软件降噪，下降沿触发
//	0x00,				//0x804e	reserved
//	0x01,				//0x804f	手指按下去抖动次数
//	0x08,				//0x8050	原始坐标窗口滤波值	
//	0x1E,				//0x8051	大面积触点个数
//	0x05,				//0x8052	噪声消除值
//	0x3C,				//0x8053	屏上触摸点从无到有的阈值
//	0x3C,				//0x8054	屏上触摸点从有到无的阈值
//	0x03,				//0x8055	进低功耗时间	s
//	0x05,				//0x8056	坐标上报率
//	0x00,				//0x8057	X坐标输出门上限
//	0x00,				//0x8058	Y坐标输出门上限
//	0x00,0x00,	//0x8059-0x805a	reserved
//	0x00,				//0x805b	reserved
//	0x00,				//0x805c	reserved
//	0x00,				//0x805d	划线过程中小filter设置
//	0x00,				//0x805e	拉伸区间	1	系数
//	0x00,				//0x805f	拉伸区间	2	系数
//	0x00,				//0x8060	拉伸区间	3	系数
//	0x14,				//0x8061	各拉伸区间基数
//	0x8A,				//0x8062	、、
//	0x2A,				//0x8063	、、
//	0x0C,				//0x8064	、、
//	0x2A,				//0x8065	驱动组A的驱动频率倍频系数
//	0x28,				//0x8066	驱动组B的驱动频率倍频系数
//	0xEB,				//0x8067	驱动组A、B的基频
//	0x04,				//0x8068	
//	0x00,				//0x8069	相邻两次驱动信号输出时间间隔
//	0x00,				//0x806a	
//	0x01,				//0x806b	、、
//	0x61,				//0x806c	、、
//	0x03,				//0x806d	原始值放大系数
//	0x2C,				//0x806e	、、
//	0x00,				//0x806f	reserved
//	0x01,				//0x8070	、、
//	0x00,0x00,	//reserved
//	0x00,				//0x8073	、、
//	0x00,0x00,0x00,0x00,0x00,0x00,	//0x8071 - 0x8079 reserved
//	0x14,				//0x807a	跳频范围的起点频率
//	0x3C,				//0x807b	跳频范围的终点频率
//	0x94,				//0x807c	多次噪声检测后确定噪声量，1-63有效
//	0xC5,				//0x807d	噪声检测超时时间
//	0x02,				//0x807e	、、	
//	0x08,				//0x807f	判别有干扰的门限
//	0x00,0x00,	//0x8081	reserved
//	0x04,				//0x8082	跳频检测区间频段1中心点基频（适用于驱动A、B）
//	0xB7,				//0x8083
//	0x16,				//0x8084	跳频检测区间频段1中心点倍频系数
//	0x00,				//0x8085	跳频检测区间频段2中心点基频(驱动A、B在此基础上换算)
//	0x9F,				//0x8086	
//	0x1B,				//0x8087	跳频检测区间频段2中心点倍频系数
//	0x00,				//0x8088	跳频检测区间频段3中心点基频（适用于驱动A、B）
//	0x8B,				//0x8089	
//	0x22,				//0x808a	跳频检测区间频段3中心点倍频系数
//	0x00,				//0x808b	跳频检测区间频段4中心点基频（适用于驱动A、B）
//	0x7B,				//0x808c	
//	0x2B,				//0x808d	跳频检测区间频段4中心点倍频系数
//	0x00,				//0x808e	跳频检测区间频段5中心点基频（适用于驱动A、B）
//	0x70,				//0x808f	
//	0x36,				//0x8090	跳频检测区间频段5中心点倍频系数
//	0x00,0x70,	//reserved
//	0x00,				//0x8093	key1位置	0：无按键
//	0x00,				//0x8094	key2位置	0：无按键
//	0x00,				//0x8095	key3位置	0：无按键
//	0x00,				//0x8096	key4位置	0：无按键
//	0x00,				//0x8097	reserved
//	0x00,				//0x8098	reserved
//	0x00,				//0x8099	reserved
//	0x00,				//0x809a	reserved
//	0x00,				//0x809b	reserved
//	0x00,				//0x809c	reserved
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x809d-0x80b2	reserved
//	0x00,				//0x80b3	合框距离
//	0x00,				//0x80b4	
//	0x00,0x00,	//0x80b6	reserved
//	0x18,				//0x80b7
//	0x16,				//0x80b8
//	0x14,				//0x80b9
//	0x12,				//0x80ba
//	0x10,				//0x80bb
//	0x0E,				//0x80bc
//	0x0C,				//0x80bd
//	0x0A,				//0x80be
//	0x08,				//0x80bf
//	0x06,				//0x80c0
//	0x04,				//0x80c1
//	0x02,				//0x80c2
//	0xFF,				//0x80c3
//	0xFF,				//0x80c4
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,	//0x80c5-0x80d4	reserved
//	0x24,				//0x80d5
//	0x22,				//0x80d6
//	0x21,				//0x80d7
//	0x20,				//0x80d8
//	0x1F,				//0x80d9
//	0x1E,				//0x80da
//	0x1D,				//0x80db
//	0x1C,				//0x80dc
//	0x18,				//0x80dd
//	0x16,				//0x80de
//	0x13,				//0x80df
//	0x12,				//0x80e0
//	0x10,				//0x80e1
//	0x0F,				//0x80e2
//	0x0A,				//0x80e3
//	0x08,				//0x80e4
//	0x06,				//0x80e5
//	0x04,				//0x80e6
//	0x02,				//0x80e7
//	0x00,				//0x80e8
//	0xFF,				//0x80e9
//	0xFF,				//0x80ea
//	0xFF,				//0x80eb
//	0xFF,				//0x80ec
//	0xFF,				//0x80ed
//	0xFF,				//0x80ee
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,	//0x80ef-0x80fe	reserved
//	0xA0, //0x80ff	配置信息校验(0x8047到0x80FE的字节和的补码)之后手动计算
//	0x01	//0x8100	配置以更新标记
//};

#else
uint8_t CTP_CFG_GT911[] =  {
  0x41,0x40,0x01,0xF0,0x00,0x05,0x0D,0x00,0x01,0x08,
  0x28,0x0F,0x50,0x32,0x03,0x05,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8A,0x2A,0x0C,
  0x45,0x47,0x0C,0x08,0x00,0x00,0x00,0x02,0x02,0x2D,
  0x00,0x00,0x00,0x00,0x00,0x03,0x64,0x32,0x00,0x00,
  0x00,0x28,0x64,0x94,0xC5,0x02,0x07,0x00,0x00,0x04,
  0x9C,0x2C,0x00,0x8F,0x34,0x00,0x84,0x3F,0x00,0x7C,
  0x4C,0x00,0x77,0x5B,0x00,0x77,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x18,0x16,0x14,0x12,0x10,0x0E,0x0C,0x0A,
  0x08,0x06,0x04,0x02,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x16,0x18,0x1C,0x1D,0x1E,0x1F,0x20,0x21,
  0x22,0x24,0x13,0x12,0x10,0x0F,0x0A,0x08,0x06,0x04,
  0x02,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x24,0x01
};
//uint8_t CTP_CFG_GT911[] = {
//	0x41,		//0x8047		版本号
//	0xF0,0x00,	//0x8048/8049	X坐标输出最大值480
//	0x40,0x01,	//0x804a/804b	Y坐标输出最大值854
//	0x01,	//0x804c	输出触点个数上限
//	0x35,	//0x804d	软件降噪，下降沿触发
//	0x00,	//0x804e	reserved
//	0x02,	//0x804f	手指按下去抖动次数
//	0x08,	//0x8050	原始坐标窗口滤波值	
//	0x28,	//0x8051	大面积触点个数
//	0x0A,	//0x8052	噪声消除值
//	0x5A,	//0x8053	屏上触摸点从无到有的阈值
//	0x46,	//0x8054	屏上触摸点从有到无的阈值
//	0x03,	//0x8055	进低功耗时间	s
//	0x05,	//0x8056	坐标上报率
//	0x00,	//0x8057	X坐标输出门上限
//	0x00,	//0x8058	Y坐标输出门上限
//	0x00,0X00,	//0x8059-0x805a	reserved
//	0x00,	//0x805b	reserved
//	0x00,	//0x805c	reserved
//	0x00,	//0x805d	划线过程中小filter设置
//	0x18,	//0x805e	拉伸区间	1	系数
//	0x1A,	//0x805f	拉伸区间	2	系数
//	0x1E,	//0x8060	拉伸区间	3	系数
//	0x14,	//0x8061	各拉伸区间基数
//	0x8C,	//0x8062	、、
//	0x28,	//0x8063	、、
//	0x0C,	//0x8064	、、
//	0x71,	//0x8065	驱动组A的驱动频率倍频系数
//	0x73,	//0x8066	驱动组B的驱动频率倍频系数
//	0xB2,	//0x8067	驱动组A、B的基频
//	0x04,	//0x8068	
//	0x00,	//0x8069	相邻两次驱动信号输出时间间隔
//	0x00,	//0x806a	
//	0x00,	//0x806b	、、
//	0x02,	//0x806c	、、
//	0x03,	//0x806d	原始值放大系数
//	0x1D,	//0x806e	、、
//	0x00,	//0x806f	reserved
//	0x01,	//0x8070	、、
//	0x00,0x00,	//reserved
//	0x00,	//0x8073	、、
//	0x00,0x00,0x00,0x00,0x00,0x00,	//0x8071 - 0x8079 reserved
//	0x50,	//0x807a	跳频范围的起点频率
//	0xA0,	//0x807b	跳频范围的终点频率
//	0x94,	//0x807c	多次噪声检测后确定噪声量，1-63有效
//	0xD5,	//0x807d	噪声检测超时时间
//	0x02,	//0x807e	、、	
//	0x07,	//0x807f	判别有干扰的门限
//	0x00,0x00,	//0x8081	reserved
//	0x04,	//0x8082	跳频检测区间频段1中心点基频（适用于驱动A、B）
//	0xA4,	//0x8083
//	0x55,	//0x8084	跳频检测区间频段1中心点倍频系数
//	0x00,	//0x8085	跳频检测区间频段2中心点基频(驱动A、B在此基础上换算)
//	0x91,	//0x8086	
//	0x62,	//0x8087	跳频检测区间频段2中心点倍频系数
//	0x00,	//0x8088	跳频检测区间频段3中心点基频（适用于驱动A、B）
//	0x80,	//0x8089	
//	0x71,	//0x808a	跳频检测区间频段3中心点倍频系数
//	0x00,	//0x808b	跳频检测区间频段4中心点基频（适用于驱动A、B）
//	0x71,	//0x808c	
//	0x82,	//0x808d	跳频检测区间频段4中心点倍频系数
//	0x00,	//0x808e	跳频检测区间频段5中心点基频（适用于驱动A、B）
//	0x65,	//0x808f	
//	0x95,	//0x8090	跳频检测区间频段5中心点倍频系数
//	0x00,	0x65,		//reserved
//	0x00,	//0x8093	key1位置	0：无按键
//	0x00,	//0x8094	key2位置	0：无按键
//	0x00,	//0x8095	key3位置	0：无按键
//	0x00,	//0x8096	key4位置	0：无按键
//	0x00,	//0x8097	reserved
//	0x00,	//0x8098	reserved
//	0x00,	//0x8099	reserved
//	0x00,	//0x809a	reserved
//	0x00,	//0x809b	reserved
//	0x00,	//0x809c	reserved
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//0x809d-0x80b2	reserved
//	0x00,	//0x80b3	合框距离
//	0x00,	//0x80b4	
//	0x00,0x00,	//0x80b6	reserved
//	0x06,	//0x80b7
//	0x08,	//0x80b8
//	0x0A,	//0x80b9
//	0x0C,	//0x80ba
//	0x0E,	//0x80bb
//	0x10,	//0x80bc
//	0x12,	//0x80bd
//	0x14,	//0x80be
//	0x16,	//0x80bf
//	0x18,	//0x80c0
//	0x1A,	//0x80c1
//	0x1C,	//0x80c2
//	0xFF,	//0x80c3
//	0xFF,	//0x80c4
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,	//0x80c5-0x80d4	reserved
//	0x00,	//0x80d5
//	0x02,	//0x80d6
//	0x04,	//0x80d7
//	0x06,	//0x80d8
//	0x08,	//0x80d9
//	0x0A,	//0x80da
//	0x0C,	//0x80db
//	0x0F,	//0x80dc
//	0x10,	//0x80dd
//	0x12,	//0x80de
//	0x13,	//0x80df
//	0x14,	//0x80e0
//	0x16,	//0x80e1
//	0x18,	//0x80e2
//	0x1C,	//0x80e3
//	0x1D,	//0x80e4
//	0x1E,	//0x80e5
//	0x1F,	//0x80e6
//	0x20,	//0x80e7
//	0x21,	//0x80e8
//	0xFF,	//0x80e9
//	0xFF,	//0x80ea
//	0xFF,	//0x80eb
//	0xFF,	//0x80ec
//	0xFF,	//0x80ed
//	0xFF,	//0x80ee
//	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,	//0x80ef-0x80fe	reserved
//	0x0B,	//0x80ff	配置信息校验
//	0x01	//0x8100	配置以更新标记
//};
#endif

static uint8_t txBuffer[100];

void GTXXXX_WriteReg(uint16_t _usRegAddr, uint8_t *_pRegBuf, uint8_t _ucLen)
{
	HAL_I2C_Mem_Write(&GT911_I2C, GT911_DIV_W, _usRegAddr, I2C_MEMADD_SIZE_16BIT, _pRegBuf, _ucLen, 0xff);
}

void GTXXXX_ReadReg(uint16_t _usRegAddr, uint8_t *_pRegBuf, uint8_t _ucLen)
{
	HAL_I2C_Mem_Read(&GT911_I2C, GT911_DIV_R, _usRegAddr, I2C_MEMADD_SIZE_16BIT, _pRegBuf, _ucLen, 0xff);
}

void GTP_Init(void)
{
	/*初始化gt9157的设备地址为0x28/0x29*/

	HAL_GPIO_WritePin (GTP_INT_GPIO_PORT,GTP_INT_GPIO_PIN,GPIO_PIN_RESET);
	HAL_GPIO_WritePin (GTP_RST_GPIO_PORT,GTP_RST_GPIO_PIN,GPIO_PIN_RESET);
	HAL_Delay(100);
	/*复位为低电平，为初始化做准备*/
	HAL_GPIO_WritePin (GTP_INT_GPIO_PORT,GTP_INT_GPIO_PIN,GPIO_PIN_SET);
	HAL_Delay(10);

	/*拉高一段时间，进行初始化*/
	HAL_GPIO_WritePin (GTP_RST_GPIO_PORT,GTP_RST_GPIO_PIN,GPIO_PIN_SET);
	HAL_Delay(10);

	/*把INT引脚设置为浮空输入模式，以便接收触摸中断信号*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.Pin = GTP_INT_GPIO_PIN;
	GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
	GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
	GPIO_InitStructure.Pull  = GPIO_NOPULL;
	HAL_GPIO_Init(GTP_INT_GPIO_PORT, &GPIO_InitStructure);
	//   HAL_NVIC_SetPriority(GTP_INT_EXTI_IRQ, 1, 1);/* 配置中断优先级 */
	//   HAL_NVIC_EnableIRQ(GTP_INT_EXTI_IRQ);/* 使能中断 */

	// 读取ID
	HAL_Delay(100);
	uint8_t GTP_ID[4];
	GTXXXX_ReadReg(GT_PID_REG,GTP_ID,4);

	sprintf((char *)txBuffer, "GTP_ID:%s\n",GTP_ID);
	CDC_Transmit_FS(txBuffer, strlen((char *)txBuffer));

	// 读取配置版本号
	HAL_Delay(100);
	uint8_t conf_version;
	GTXXXX_ReadReg(GT_CFGS_REG, &conf_version, 1);
	CTP_CFG_GT911[0] = conf_version;
	sprintf((char *)txBuffer, "Conf Version:0x%X\n", conf_version);
	CDC_Transmit_FS(txBuffer, strlen((char *)txBuffer));

	// 计算校验和
	HAL_Delay(100);
	uint8_t conf_checksum = 0;
	for(int i=0; i < sizeof(CTP_CFG_GT911) - 2; i++)
	{
		conf_checksum += CTP_CFG_GT911[i];
	}
	conf_checksum = (~conf_checksum) + 1; // 补码为原码按位取反加一
	CTP_CFG_GT911[184] = conf_checksum; // 总共186个R/W寄存器，下标0-185，Checksum下标184
	sprintf((char *)txBuffer, "Conf Checksum:0x%X\n", conf_checksum);
	CDC_Transmit_FS(txBuffer, strlen((char *)txBuffer));
	
	// 写入配置表
	GTXXXX_WriteReg(GT_CFGS_REG, (uint8_t *)CTP_CFG_GT911, sizeof(CTP_CFG_GT911));
	HAL_Delay(100);

	// 转换为软复位模式
	uint8_t _temp=2;	//中间变量
	GTXXXX_WriteReg(GT_CTRL_REG, &_temp, 1);
	HAL_Delay(100);

	// 转换为读取坐标模式
	_temp=0;	//中间变量
	GTXXXX_WriteReg(GT_CTRL_REG, &_temp, 1);

}

/*
	功能：gt911触摸扫描，判断当前是否被触摸
	参数1：
*/
void GTXXXX_Scanf(void)
{
	uint8_t _temp;	//中间变量

	GTXXXX_ReadReg(GT_GSTID_REG, &_temp, 1);//读取状态寄存器

	// 记录触摸状态
	User_Touch.Touch_State = _temp;
	User_Touch.Touch_Number = (User_Touch.Touch_State & 0x0f);	//获取触摸点数
	User_Touch.Touch_State = (User_Touch.Touch_State & 0x80);	//触摸状态

	//判断是否有触摸数据
	switch(User_Touch.Touch_State)
	{
		case TOUCH__NO:		//没有数据
			break;
		case TOUCH_ING:		//触摸中~后，有数据，并读出数据
			for(uint8_t i=0; i<User_Touch.Touch_Number; i++)
			{
				GTXXXX_ReadReg((GT_TPD_Sta + i*8 + X_L), &_temp, 1);	//读出触摸x坐标的低8位
				User_Touch.Touch_XY[i].X_Point  = _temp;
				GTXXXX_ReadReg((GT_TPD_Sta + i*8 + X_H), &_temp, 1);	//读出触摸x坐标的高8位
				User_Touch.Touch_XY[i].X_Point |= (_temp<<8);

				GTXXXX_ReadReg((GT_TPD_Sta + i*8 + Y_L), &_temp, 1);	//读出触摸y坐标的低8位
				User_Touch.Touch_XY[i].Y_Point  = _temp;
				GTXXXX_ReadReg((GT_TPD_Sta + i*8 + Y_H), &_temp, 1);	//读出触摸y坐标的高8位
				User_Touch.Touch_XY[i].Y_Point |= (_temp<<8);

				GTXXXX_ReadReg((GT_TPD_Sta + i*8 + S_L), &_temp, 1);	//读出触摸大小数据的低8位
				User_Touch.Touch_XY[i].S_Point  = _temp;
				GTXXXX_ReadReg((GT_TPD_Sta + i*8 + S_H), &_temp, 1);	//读出触摸大小数据的高8位
				User_Touch.Touch_XY[i].S_Point |= (_temp<<8);
			}

			_temp=0;
			GTXXXX_WriteReg(GT_GSTID_REG, &_temp, 1);	//清除数据标志位
		break;
	}
}

extern uint8_t flagTouch;
extern uint16_t touchPoint[2]; // {x,y}
void GTP911_Test(void)
{
	GTXXXX_Scanf();		//不断扫描
	if(User_Touch.Touch_State == 0x80)
	{
		for(uint8_t i=0; i<User_Touch.Touch_Number; i++)
		{
			sprintf((char *)txBuffer, "X:%d\tY:%d\tS:%dNum:%dIndex:%d\n", User_Touch.Touch_XY[i].X_Point, User_Touch.Touch_XY[i].Y_Point, User_Touch.Touch_XY[i].S_Point, User_Touch.Touch_Number, i);
			CDC_Transmit_FS(txBuffer, strlen((char *)txBuffer));
		}
		User_Touch.Touch_State  = 0;
		User_Touch.Touch_Number = 0;
		
		flagTouch = 1;
		
		// 校准
//		if(User_Touch.Touch_XY[0].X_Point >= 232) User_Touch.Touch_XY[0].X_Point -= 79;
//		User_Touch.Touch_XY[0].X_Point -= 57;
//		
//		touchPoint[0] = 320 - (User_Touch.Touch_XY[0].X_Point * 320 / 181);
//		touchPoint[1] = 240 - (User_Touch.Touch_XY[0].Y_Point - 50) * 240 / 186;
		touchPoint[0] = User_Touch.Touch_XY[0].X_Point;
		if(User_Touch.Touch_XY[0].X_Point >= 232){
			touchPoint[0] -= 79;
		}
		touchPoint[0] = 320 - (touchPoint[0] - 57) * 320 / 181;
//		touchPoint[0] = 320 - User_Touch.Touch_XY[0].X_Point;
		touchPoint[1] = 240 - (User_Touch.Touch_XY[0].Y_Point - 50) * 240 / 186;
	}
}


